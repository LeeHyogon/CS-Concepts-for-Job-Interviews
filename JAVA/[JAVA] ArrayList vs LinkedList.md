### ArrayList API 

* add(E element): 원소를 마지막에 추가하기
배열에 마지막에 원소를 추가하는 것이기 때문에 빠르게 추가할 수 있습니다.
  * 시간 복잡도: O(1)

* add(int index, E element): 원소를 지정된 위치에 추가하기
underlying array를 복사하고, 이동하는 작업이 필요하기 때문에
  * 시간 복잡도: O(n)

* remove(int index): 원소의 인덱스로 삭제하기
마지막 원소를 삭제한다면 쉽게 삭제할 수 있지만 중간이나 처음의 원소를 삭제하게 되면 
index 위치부터 다음 index 위치까지 모든 element를 이동시켜야하기 때문에 
  * 시간 복잡도: O(n)

* get(int index): 인덱스에 해당하는 원소 찾아오기
ArrayList는 내부적으로 배열을 사용하기 때문에 인덱스로 직접 접근할 수 있으므로
  * 시간 복잡도: O(1)

간단하게 정리하면 ArrayList는 탐색은 빠르게 할 수 있지만, 중간에서 추가, 삭제가 빈번하게 일어나면 비효율적인 특징을 가지고 있습니다.

=======================


### LinkedList API

* add(E element): 원소를 마지막에 추가하기
LinkedList도 마찬가지로 add 메소드가 존재합니다. 
Tail이 존재하므로 
  * 시간 복잡도: O(1)

* add(int index, E element) 메소드: 리스트의 특정 위치에 요소를 추가하는 메소드로, 
해당 위치까지 순회해야 하므로 
  * 시간 복잡도: O(n)

* remove(int index) : 지정한 인덱스에 해당하는 요소를 리스트에서 제거합니다.
해당 위치까지 순회하여 삭제하므로,
  * 시간 복잡도: O(n)

* removeFirst() : 리스트의 맨 앞 요소를 제거합니다. Head를 이용하여 쉽게 접근하므로
  * 시간 복잡도: O(1) 

* removeLast() : 리스트의 맨 끝 요소를 제거합니다. Tail을 이용하여 쉽게 접근하므로
  * 시간 복잡도: O(1)

* get(int index): 인덱스에 해당하는 원소 찾아오기
LinkedList는 ArrayList와 다르게 인덱스를 통해서 검색을 하는 것이 아니라
Head에서 부터 해당 원소 까지 검색해야 하기 때문에 
  * 시간 복잡도: O(n)


LinkedList는 리스트의 맨 앞과 맨 끝에 대한 추가/제거 연산에는 매우 빠르지만, 
중간에 요소를 추가하거나 제거하는 경우에는 인덱스를 찾아야 하므로 시간 복잡도가 O(n)이 됩니다.

### 결론

* LinkedList는 요소의 추가/제거가 빈번하지 않은 경우에는 성능이 좋지만, 
빈번하게 일어나는 경우에는 ArrayList나 다른 자료구조를 고려해보는 것이 좋습니다.
* ArrayList는 데이터의 추가/삭제보다는 데이터의 조회에 적합합니다.



