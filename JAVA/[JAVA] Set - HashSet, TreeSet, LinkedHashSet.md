## Set

Set은 순서가 없고 중복을 허용하지 않는 자료구조이다.
        
      
### HashSet
* HashSet은 Set 인터페이스를 구현하며, 내부적으로 HashMap을 사용하여 요소들을 저장한다.</br>
* HashSet은 Set의 특성상 중복되는 요소를 허용하지 않으며, 요소의 순서도 유지하지 않는다.즉, 요소의 저장 순서와 출력 순서가 다를 수 있다.</br>
* HashSet의 경우 Hash 알고리즘 기반으로 동작.</br>
* HashSet은 내부적으로 HashMap의 key를 이용하여 데이터를 저장하기 때문에 검색, 삽입, 삭제에 대해 상수시간(O(1))으로 처리할 수 있다.</br>

#### HashSet의 시간복잡도 O(h/n) 

HashSet에서 h는 버킷 수, n은 저장된 element 수이다. 
HashSet은 내부적으로 해시 함수를 사용하여 요소를 버킷에 매핑하고 저장한다. 
따라서 요소를 검색하거나 삽입하려면 요소를 해시 함수를 사용하여 버킷에 매핑해야한다.

HashSet에서 요소를 검색하려면 먼저 해당 요소의 해시 값과 동일한 버킷을 찾아야한다. 
해시 값은 일반적으로 상수 시간에 계산된다. 
그러나 버킷에 저장된 요소의 수가 많아지면 같은 해시 값으로 매핑되는 요소들이 많아져 충돌이 발생할 가능성이 높아진다. 
이 때문에 HashSet에서는 각 버킷에 대해 링크드 리스트(Java 8부터는 트리)로 구성된 버킷 리스트를 사용하여 충돌을 처리한다.

따라서, HashSet에서 검색 및 삽입 연산의 평균 시간 복잡도는 O(h/n)이 된다. 
최선의 경우에는 모든 요소가 다른 버킷에 저장되어 O(1)의 시간 복잡도를 가질 수 있지만, 
최악의 경우에는 모든 요소가 같은 버킷에 저장되어 링크드 리스트(Java 8부터는 트리)의 모든 요소를 순회해야하므로 O(n)의 시간 복잡도를 가진다.
 하지만 평균적으로는 버킷 수가 충분히 크다면(즉, h가 충분히 크다면) 충돌이 상대적으로 적게 발생하므로 O(1)의 상수 시간에 연산을 수행할 수 있다. 


### TreeSet
* TreeSet은 이진 검색 트리(Binary Search Tree)를 사용하여 요소를 저장한다.
* TreeSet의 경우 이진트리의 향상된 버전인 Red-Black Tree를 기반으로 만들어진다.
* TreeSet은 Set의 특성상 중복되는 요소를 허용하지 않으며, 저장된 요소들은 오름차순 정렬되어 저장된다. 

#### TreeSet의 시간 복잡도
- 데이터 삽입: O(log n)
- 데이터 삭제: O(log n)
- 데이터 검색: O(log n)
- 최소값/최대값 검색: O(1)
</br>
TreeSet의 최악의 시간 복잡도는 O(n)이 아니라 O(log n)이다. </br></br>
이는 TreeSet이 내부적으로 이진 탐색 트리(Binary Search Tree)를 사용하기 때문이다. </br></br>
따라서 TreeSet에서 데이터를 삽입하거나 삭제하거나 검색하는 경우, 
이진 탐색 트리의 높이(height)에 따라 시간 복잡도가 결정된다. </br></br>
이진 탐색 트리의 높이는 데이터의 추가 순서에 따라 달라질 수 있지만, 
대부분의 경우 O(log n) 이하의 높이를 가진다. </br>

하지만, 이진 탐색 트리가 한쪽으로 치우쳐져 있는 경우에는 최악의 시간 복잡도가 O(n)이 될 수도 있다. 


### LinkedHashSet
* LinkedHashSet은 HashSet과 비슷하게 Set 인터페이스를 구현하며, 내부적으로 LinkedHashMap을 사용하여 요소들을 저장한다. 

* LinkedHashSet은 삽입 순서를 보장하기 때문에, 삽입 순서대로 데이터를 처리해야 할 경우 사용할 수 있다.

* HashSet은 내부적으로 HashMap을 사용하고, TreeSet은 이진 검색 트리를 사용한다는 점에서 메모리 사용과 시간 복잡도 등에서 차이가 있다.
 
* LinkedHashSet은 삽입 순서를 보장하면서 중복된 요소를 허용하지 않으므로, HashSet과 TreeSet의 특징을 모두 가지고 있다.


        