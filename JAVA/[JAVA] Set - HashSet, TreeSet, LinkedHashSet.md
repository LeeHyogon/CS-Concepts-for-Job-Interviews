## Set

Set은 순서가 없고 중복을 허용하지 않는 자료구조이다.
        
      
### HashSet
* Set 인터페이스를 구현하며, 내부적으로 HashMap을 사용하여 요소들을 저장한다.

#### HashSet의 시간복잡도 
- 데이터 삽입: O(1)
- 데이터 삭제: O(1)
- 데이터 검색: O(1)

#### 버킷 충돌 시 HashSet의 시간복잡도 O(h/n) 

HashSet에서 h는 버킷 수, n은 저장된 element 수이다. </br>
HashSet은 내부적으로 해시 함수를 사용하여 요소를 버킷에 매핑하고 저장한다.

버킷에 저장된 요소의 수가 많아지면 같은 해시 값으로 매핑되는 요소들이 많아져 충돌이 발생할 가능성이 높아진다. 

이 때문에 HashSet에서는 각 버킷에 대해 링크드 리스트(Java 8부터는 트리)로 구성된 버킷 리스트를 사용하여 충돌을 처리한다.

따라서, HashSet에서 검색 및 삽입 연산의 평균 시간 복잡도는 O(h/n)이 된다. 

- 최선의 경우: O(1)
- 최악의 경우: O(n) (버킷이 하나밖에 없을 때)
- 최악의 경우: O(log n) 
(JDK8 이후 버킷에 8개 이상 달려있을 때, Balanced Tree로 변환됨)
 
#### 장점
 - 빠른 검색 속도
 - 중복된 원소 제거
 
#### 단점
 - 순서가 없고 그렇기에 인덱스도 존재하지 않음
 - 해시 충돌
 - 해시 테이블 사용으로 메모리 사용량 증가


### TreeSet
* 이진트리의 향상된 버전인 Red-Black Tree를 기반으로 만들어진다.
* Red-Black Tree는 불균형을 스스로 복원하는 자가 균형 이진 탐색트리

#### TreeSet의 시간 복잡도
- 데이터 삽입: O(log n)
- 데이터 삭제: O(log n)
- 데이터 검색: O(log n)
- 데이터 범위 탐색: O(log n)
- 최소값/최대값 검색: O(1)

TreeSet의 최악의 시간 복잡도는 O(n)이 아니라 O(log n)이다.

이는 TreeSet이 내부적으로 이진 탐색 트리(Binary Search Tree)를 사용하기 때문이다. 

따라서 TreeSet에서 데이터를 삽입하거나 삭제하거나 검색하는 경우, 
이진 탐색 트리의 높이(height)에 따라 시간 복잡도가 결정된다. 

이진 탐색 트리의 높이는 데이터의 추가 순서에 따라 달라질 수 있지만, 
대부분의 경우 O(log n) 이하의 높이를 가진다.

하지만, 이진 탐색 트리가 한쪽으로 치우쳐져 있는 경우에는 최악의 시간 복잡도가 O(n)이 될 수도 있다.

#### 장점
- **범위 탐색이 가능하다.**
- 저장된 요소들은 오름차순 정렬되어 저장된다. 

#### 단점
- 정렬된 상태를 유지하기 위해 삽입, 삭제 연산 시에 추가적인 비용이 발생
- 이진 검색 트리의 특성상 데이터가 불균형하게 저장될 경우 연산 속도 떨어짐(Red-Black Tree 기반으로 문제 해결)
### LinkedHashSet
* Set 인터페이스를 구현하며, 내부적으로 LinkedHashMap을 사용하여 요소들을 저장한다. 

#### LinkedHashSet의 시간복잡도 
- 데이터 삽입: O(1)
- 데이터 삭제: O(1)
- 데이터 검색: O(1)

#### 장점
- 빠른 검색 속도
- 삽입 순서를 보장한다.

#### 단점
- HashSet보다 삽입 비용이 더 든다.
- 내부적으로 정렬을 유지하기 위해 속도가 더 느리다.
        
